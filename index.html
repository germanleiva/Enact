<!DOCTYPE html>
<html>

<head>
    <title>Enact</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.3.1/css/bulma.min.css">
    <link rel="stylesheet" type="text/css" href="index.css">
</head>

<body>
    <div id="toolbar">
        <div class="block">
            <a class="button" :class="{'is-active':selectionMode}" v-on:click="selectionSelected">Selection</a>
            <a class="button" :class="{'is-active':drawMode}" v-on:click="drawSelected">Draw</a>
            <a class="button">Measure</a>
            <a class="button" v-on:click="changeToBlue">Change to blue</a>
            <a class="button" v-on:click="changeToRed">Change to red</a>
            <a class="button" v-on:click="addVisualState">Add VisualState</a>
        </div>
    </div>
    <div id="outputArea" class="outputArea" v-bind:style='{cursor: cursorType}'></div>
    <script src="https://unpkg.com/vue/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/lodash/4.17.4/lodash.min.js"></script>
    <script>
    window.addEventListener('keydown', function(e) {
        if (e.code === 'AltLeft' || e.code === 'AltRight') {
            toolbarVM.multiSelectionMode = true;
        }
    });
    window.addEventListener('keyup', function(e) {
        toolbarVM.multiSelectionMode = false;
    });

    class ShapeModel {
        constructor(color, top, left, width, height) {
            this.id = 'Polygon';

            this.currentVersion = new ShapeModelVersion(this, {
                value: color
            }, {
                x: left,
                y: top
            }, {
                w: width,
                h: height
            })
        }
    }

    class ShapeModelVersion {
        constructor(model, color, translation, scaling) {
            this.model = model;
            this.backgroundColor = color;
            this.translation = translation;
            this.scaling = scaling;
            this.masterVersion = undefined;
        }
        get top() {
            if (this.masterVersion) {
                return this.masterVersion.top;
            }
            return this.translation.y;
        }
        get left() {
            if (this.masterVersion) {
                return this.masterVersion.left;
            }
            return this.translation.x;
        }
        get width() {
            if (this.masterVersion) {
                return this.masterVersion.width;
            }
            return this.scaling.w;
        }
        get height() {
            if (this.masterVersion) {
                return this.masterVersion.height;
            }
            return this.scaling.h;
        }
        get color() {
            if (this.masterVersion) {
                return this.masterVersion.color;
            }
            return this.backgroundColor.value;
        }
        set top(value) {
            this.translation.y = value;
        }
        set left(value) {
            this.translation.x = value;
        }
        set width(value) {
            this.scaling.w = value;
        }
        set height(value) {
            this.scaling.h = value;
        }
        set color(value) {
            this.backgroundColor.value = value;
        }
    }

    var VisualState = Vue.extend({
        template: '<div v-on:mousedown="actionStarted" class="visualState"></div>',
        data: function() {
            return {
                shapes: [],
                startingPosition: {
                    x: 0,
                    y: 0
                },
                nextState: undefined,
                previousState: undefined
            }
        },
        methods: {
            shapes() {
                return
            },
            selectedShapes: function() {
                return this.shapes.filter(function(each) {
                    return each.isSelected;
                });
            },
            actionStarted: function(e) {
                if (toolbarVM.drawMode) {
                    this.drawingStarted(e);
                } else if (toolbarVM.selectionMode) {
                    //We traverse the shapes in backward order
                    var selectedShape = null;
                    for (var i = this.shapes.length - 1; i >= 0; i--) {
                        var each = this.shapes[i];
                        if (each.isPointInside(e.x, e.y)) {
                            each.toggleSelection();
                            if (each.isSelected) {
                                selectedShape = each;
                            }
                            this.moveStarted(e, each);
                            continue;
                        }
                    }
                    if (!toolbarVM.multiSelectionMode) {
                        _.each(this.selectedShapes(), function(previouslySelectedShape) {
                            if (previouslySelectedShape !== selectedShape) {
                                previouslySelectedShape.deselect();
                            }
                        });
                    }

                }
            },

            //DRAWING METHODS
            drawingStarted: function(e) {
                var newShapeVM = this.addNewShape();

                var mouseMoveHandler

                mouseMoveHandler = function(e) {
                    this.drawingChanged(e, newShapeVM)
                }.bind(this)

                var mouseUpHandler
                mouseUpHandler = function(e) {
                    this.drawingEnded(e, newShapeVM)
                    this.$el.removeEventListener('mousemove', mouseMoveHandler, false);
                    this.$el.removeEventListener('mouseup', mouseUpHandler, false);
                }.bind(this)

                this.$el.addEventListener('mousemove', mouseMoveHandler, false);
                this.$el.addEventListener('mouseup', mouseUpHandler, false);

                newShapeVM.startingPosition.x = e.x;
                newShapeVM.startingPosition.y = e.y;
            },

            drawingChanged: function(e, newShapeVM) {
                this.updateShapeProperties(e, newShapeVM);
            },

            drawingEnded: function(e, newShapeVM) {
                outputAreaVM.$emit('didCreateShape', newShapeVM, this);
            },

            updateShapeProperties: function(e, newShapeVM) {
                //Maybe this should go in Shape
                var topValue = newShapeVM.startingPosition.y
                if (e.y < newShapeVM.startingPosition.y) {
                    topValue = e.y;
                }

                var leftValue = newShapeVM.startingPosition.x
                if (e.x < newShapeVM.startingPosition.x) {
                    leftValue = e.x;
                }
                var widthValue = Math.abs(e.x - newShapeVM.startingPosition.x);
                var heightValue = Math.abs(e.y - newShapeVM.startingPosition.y)

                newShapeVM.version.top = topValue - this.$el.offsetTop;
                newShapeVM.version.left = leftValue - this.$el.offsetLeft;
                newShapeVM.version.width = widthValue;
                newShapeVM.version.height = heightValue;
            },


            //MOVING METHODS
            moveStarted: function(e, selectedShapeVM) {

                var offsetY = e.y - selectedShapeVM.version.top;
                var offsetX = e.x - selectedShapeVM.version.left;

                var parentElement = selectedShapeVM.$el.parentNode;
                //When the second parameter is null in insertBefore the element is added as the last child
                parentElement.insertBefore(selectedShapeVM.$el, null);

                var moveHandler = function(e) {
                    this.moveChanged(e, selectedShapeVM, offsetX, offsetY);
                }.bind(this);
                this.$el.addEventListener('mousemove', moveHandler, false);

                var visualOuputElement = this.$el;
                var upHandler
                upHandler = function(e) {
                    visualOuputElement.removeEventListener('mousemove', moveHandler, false);
                    visualOuputElement.removeEventListener('mouseup', upHandler, false);
                }
                this.$el.addEventListener('mouseup', upHandler, false);
            },

            moveChanged: function(e, selectedShapeVM, initialOffsetX, initialOffsetY) {
                selectedShapeVM.isSelected = true;
                selectedShapeVM.version.top = Math.abs(initialOffsetY - e.y);
                selectedShapeVM.version.left = Math.abs(initialOffsetX - e.x);
                selectedShapeVM.version.masterVersion = undefined;
                // if (this.nextState) {
                // this.nextState.somethingChanged(selectedShapeVM.version, selectedShapeVM);
                // }
            },
            somethingChanged(version, shapeVM) {
                this.$forceUpdate();
            },
            propertyChanged: function(cssStyle) {
                _.each(this.selectedShapes(), function(shapeVM) {
                    shapeVM.version.color = cssStyle['background-color'];
                });
            },
            addNewShape(oldShapeVM) {
                var newShapeVM = new ShapeVM();

                if (oldShapeVM) {
                    //Cheap way of cloning the version
                    newShapeVM.version = new ShapeModelVersion(oldShapeVM.version.model, {
                        value: oldShapeVM.version.backgroundColor.value
                    }, {
                        x: oldShapeVM.version.translation.x,
                        y: oldShapeVM.version.translation.y
                    }, {
                        w: oldShapeVM.version.scaling.w,
                        h: oldShapeVM.version.scaling.h
                    });



                    newShapeVM.version.masterVersion = oldShapeVM.version;
                } else {
                    let newShape = new ShapeModel('white', 0, 0, 0, 0);
                    newShapeVM.version = newShape.currentVersion;
                }

                if (oldShapeVM) {
                    newShapeVM.isSelected = oldShapeVM.isSelected
                    newShapeVM.startingPosition = {
                        x: oldShapeVM.startingPosition.x,
                        y: oldShapeVM.startingPosition.y
                    }
                }

                newShapeVM.$mount();
                this.$el.appendChild(newShapeVM.$el);
                this.shapes.push(newShapeVM);

                return newShapeVM;
            }
        }
    });

    var ShapeVM = Vue.extend({
        template: "<div v-bind:style='styleObject'></div>",
        data: function() {
            return {
                color: 'white',
                isSelected: false,
                startingPosition: {
                    x: 0,
                    y: 0
                },
                version: undefined
            }
        },
        computed: {
            styleObject: function() {
                return {
                    'backgroundColor': this.version.color,
                    'position': 'absolute',
                    'top': this.version.top + 'px',
                    'left': this.version.left + 'px',
                    'width': this.version.width + 'px',
                    'height': this.version.height + 'px',
                    'border': (this.isSelected ? '4px' : '1px') + ' solid gray'
                }
            }
        },
        methods: {
            isPointInside: function(windowX, windowY) {
                let x = windowX - this.$el.parentElement.offsetLeft;
                let y = windowY - this.$el.parentElement.offsetTop;
                return this.version.top < y && this.version.left < x && x < this.version.left + this.version.width && y < this.version.top + this.version.height;

            },
            toggleSelection() {
                this.isSelected = !this.isSelected;
            },
            deselect() {
                if (this.isSelected) {
                    this.isSelected = false;
                }
            },
            propertyChanged(cssStyle) {


            }
        }
    });

    // create a new Vue instance and mount it to our div element above with the id of app
    var outputAreaVM = new Vue({
        el: '#outputArea',
        data: {
            visualStates: [],
            cursorType: 'auto'
        },
        methods: {
            propertyChangedOnSelectedShape: function(cssStyle) {
                _.each(this.visualStates, function(each) {
                    each.propertyChanged(cssStyle);
                });
            }
        },
        created: function() {
            this.$on('didCreateShape', function(createdShape, currentVisualState) {
                var currentVisualStateIndex = this.visualStates.indexOf(currentVisualState);
                for (var i = 0; i < this.visualStates.length; i++) {
                    if (i > currentVisualStateIndex) {
                        var futureVisualState = this.visualStates[i];
                        futureVisualState.addNewShape(createdShape);
                    }
                }
            })
        }
    });

    var toolbarVM = new Vue({
        el: '#toolbar',
        data: {
            drawMode: false,
            selectionMode: true,
            multiSelectionMode: false
        },
        methods: {
            drawSelected() {
                this.drawMode = true;
                this.selectionMode = false;
                outputAreaVM.cursorType = "crosshair";
            },
            selectionSelected() {
                this.drawMode = false;
                this.selectionMode = true;
                outputAreaVM.cursorType = "default";
            },
            changeToBlue() {
                outputAreaVM.propertyChangedOnSelectedShape({
                    'background-color': 'blue'
                });
            },
            changeToRed() {
                outputAreaVM.propertyChangedOnSelectedShape({
                    'background-color': 'red'
                });
            },

            addVisualState() {
                var allTheVisualStates = outputAreaVM.$data.visualStates;
                var newVisualState = new VisualState().$mount()

                if (allTheVisualStates.length > 0) {
                    var previousVisualState = _.last(allTheVisualStates);

                    _.each(previousVisualState.shapes, function(previousShape) {
                        newVisualState.addNewShape(previousShape);
                    });

                    previousVisualState.nextState = newVisualState;
                    newVisualState.previousState = previousVisualState;
                }

                outputAreaVM.$el.appendChild(newVisualState.$el)

                allTheVisualStates.push(newVisualState);
            }
        },
        created: function() {
            this.addVisualState();
        }

    });
    </script>
</body>

</html>
